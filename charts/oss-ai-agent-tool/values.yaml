image:
  repo: ghcr.io/yourorg/oss-ai-agent-tool
  tag: "0.1.0"
  pullPolicy: IfNotPresent

runMode: consumer

messaging:
  type: rabbitmq
  kafka:
    brokers: []
    clientId: oss-orchestrator
    consumerGroup: orchestrator-plan-runtime
    consumeFromBeginning: false
    retryDelayMs: 1000
    topics:
      planSteps: plan.steps
      planCompletions: plan.completions
      planEvents: plan.events
      planState: plan.state
      deadLetterSuffix: ".dead"
    tls:
      enabled: false
      secretName: ""
      mountPath: /etc/kafka/tls
      caFile: ca.crt
      certFile: tls.crt
      keyFile: tls.key
      caPaths: []
      certPath: ""
      keyPath: ""
      rejectUnauthorized: true
    sasl:
      mechanism: ""
      username: ""
      password: ""
      passwordSecretName: ""
      passwordSecretKey: password
    ensureTopics: true
    topicPartitions: 3
    replicationFactor: 3
    topicDefaultConfig: ""
    compactTopics: []

vault:
  enabled: false
  address: https://vault.default.svc:8200
  authMethod: kubernetes
  role: oss-ai-orchestrator
  namespace: ""
  tokenSecretName: ""
  tokenSecretKey: token
  serviceAccountName: ""
  kubernetes:
    jwtPath: /var/run/secrets/kubernetes.io/serviceaccount/token

auth:
  oidc:
    enabled: false
    issuer: ""
    redirectBaseUrl: ""
    clientId: ""
    clientSecretSecretName: ""
    clientSecretKey: client-secret
    tenantClaim: ""
    audience: ""
    scopes:
      - openid
      - profile
      - email
    extraScopes: []
    logoutUrl: ""

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65532
  runAsGroup: 65532
  fsGroup: 65532

containerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

mtls:
  enabled: false
  certManager:
    enabled: true
    issuerRef:
      name: ""
      kind: ClusterIssuer
      group: cert-manager.io
    duration: 2160h # 90 days
    renewBefore: 360h # 15 days
    privateKey:
      algorithm: ECDSA
      size: 256
  orchestrator:
    additionalDnsNames: []
  gateway:
    client:
      commonName: ""
      organizations: []

networkPolicy:
  enabled: true
  ingress:
    - from:
        - podSelector: {}
        - namespaceSelector: {}
  defaultDenyEgress: true
  egressRules:
    # Allow DNS queries to kube-dns inside kube-system
    - to:
        - namespaceSelector:
            matchLabels:
              kubernetes.io/metadata.name: kube-system
          podSelector:
            matchLabels:
              k8s-app: kube-dns
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
    # Allow OTLP/HTTP traffic to the bundled Jaeger collector
    - to:
        - podSelector:
            matchLabels:
              app.kubernetes.io/component: jaeger
      ports:
        - protocol: TCP
          port: 4317

gatewayApi:
  replicas: 2
  containerPort: 8080
  service:
    type: ClusterIP
    port: 80
  env: {}
  requestLimitBytes: 1048576
  tolerations: []
  nodeSelector: {}
  affinity: {}
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    fsGroup: 65532
    seccompProfile:
      type: RuntimeDefault
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
  serviceAccount:
    create: true
    name: ""
    annotations: {}
  sse:
    maxConnectionsPerIP: 4
  rateLimit:
    redis:
      enabled: true
      url: ""
    auth:
      ip:
        window: 5m
        maxRequests: 100
      identity:
        window: 1m
        maxRequests: 20
  tls:
    enabled: false
    secretName: ""
    mountPath: /etc/orchestrator/tls
    clientCertFile: client.crt
    clientKeyFile: client.key
    caFile: ca.crt
    serverName: ""
  resources:
    requests: { cpu: "100m", memory: "128Mi" }
    limits: { cpu: "500m", memory: "256Mi" }
  tracing:
    enabled: true
    endpoint: ""
    sampleRatio: 1.0
    environment: "development"
    headers: {}
  podDisruptionBudget:
    enabled: true
    minAvailable: 1

orchestrator:
  replicas: 2
  containerPort: 4000
  service:
    type: ClusterIP
    port: 4000
  serviceAccount:
    create: true
    name: ""
    annotations: {}
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    fsGroup: 65532
    seccompProfile:
      type: RuntimeDefault
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
  env:
    LOCAL_SECRETS_PATH: /app/config/secrets/local/secrets.json
  localSecrets:
    passphrase: ""
    passphraseSecretName: ""
    passphraseSecretKey: passphrase
  tls:
    enabled: false
    secretName: ""
    mountPath: /etc/orchestrator/tls
    certFile: tls.crt
    keyFile: tls.key
    caFile: ca.crt
    requestClientCert: true
  sseQuotas:
    maxConnectionsPerIP: 4
    maxConnectionsPerSubject: 2
  rateLimits:
    backend:
      provider: memory
      redis:
        url: ""
    plan:
      windowMs: 60000
      maxRequests: 60
      identityWindowMs: null
      identityMaxRequests: null
    chat:
      windowMs: 60000
      maxRequests: 600
      identityWindowMs: null
      identityMaxRequests: null
    auth:
      windowMs: 60000
      maxRequests: 120
      identityWindowMs: 60000
      identityMaxRequests: 20
  requestLimits:
    jsonBytes: 1048576
    urlEncodedBytes: 1048576
  database:
    postgres:
      maxConnections: 20
      minConnections: 2
      idleTimeoutMs: 30000
      connectionTimeoutMs: 5000
      maxConnectionLifetimeMs: 1800000
      statementTimeoutMs: 5000
      queryTimeoutMs: 5000
  policy:
    cache:
      enabled: false
      provider: memory
      ttlSeconds: 60
      redis:
        url: ""
        keyPrefix: policy:decision
      maxEntries: 10000
  hpa:
    enabled: true
    min: 2
    max: 10
    targetQueueDepth: 5
    metricSelector:
      queue: plan.steps
      # tenant: demo       # Uncomment to scope the HPA to a specific tenant label.
  resources:
    requests: { cpu: "200m", memory: "256Mi" }
    limits: { cpu: "1", memory: "512Mi" }
  tracing:
    enabled: true
    endpoint: ""
    sampleRatio: 1.0
    environment: "development"
    headers: {}
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
    serviceName: oss-ai-orchestrator

indexer:
  enabled: true
  replicas: 1
  containerPort: 7070      # gRPC port
  httpContainerPort: 7071  # HTTP port (health checks, REST API)
  logLevel: info
  requestLimitBytes: 1048576
  env: {}
  serviceAccount:
    create: true
    name: ""
    annotations: {}
  auth:
    disabled: false
    jwt:
      secret: ""
      secretSecretName: ""
      secretSecretKey: secret
      issuer: ""
      audience: ""
  tolerations: []
  nodeSelector: {}
  affinity: {}
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    fsGroup: 65532
    seccompProfile:
      type: RuntimeDefault
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
  service:
    type: ClusterIP
    port: 7070      # gRPC port
    httpPort: 7071  # HTTP port (health checks, REST API)
  resources:
    requests: { cpu: "100m", memory: "128Mi" }
    limits: { cpu: "500m", memory: "256Mi" }
  tracing:
    enabled: true
    endpoint: ""
    sampleRatio: 1.0
    environment: "development"
    headers: {}
  podDisruptionBudget:
    enabled: true
    minAvailable: 1
    serviceName: oss-indexer

redis:
  enabled: true
  image: bitnami/redis:7.2
  podSecurityContext:
    runAsNonRoot: true
    fsGroup: 1001
    seccompProfile:
      type: RuntimeDefault
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
  persistence:
    enabled: false
    size: 1Gi
    storageClass: ""
  resources: {}

postgres:
  enabled: true
  image: bitnami/postgresql:15
  podSecurityContext:
    runAsNonRoot: true
    fsGroup: 1001
    seccompProfile:
      type: RuntimeDefault
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
  database: ossaat
  username: ossaat
  # When left empty and postgres.enabled=true, the orchestrator falls back to the bundled Secret's password (default "ossaat").
  # Override this with a strong value for real deployments.
  password: ""
  url: ""
  urlSecretName: ""
  urlSecretKey: url
  persistence:
    size: 8Gi
    storageClass: ""
  resources: {}

rabbitmq:
  enabled: true
  image: bitnami/rabbitmq:3.13
  podSecurityContext:
    runAsNonRoot: true
    fsGroup: 1001
    seccompProfile:
      type: RuntimeDefault
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
  username: ""
  password: ""
  host: ""
  port: 5672
  scheme: amqp
  vhost: ""
  url: ""
  urlSecretName: ""
  urlSecretKey: url
  persistence:
    enabled: false
    size: 5Gi
    storageClass: ""
  resources: {}

kafka:
  enabled: false
  image: bitnami/kafka:3.7.0
  persistence:
    enabled: false
    size: 10Gi
    storageClass: ""
  resources: {}

monitoring:
  prometheus:
    alerts:
      enabled: false
      evaluationInterval: "30s"
      thresholds:
        providerErrorRate: 0.05
        providerLatencyP95: 5
        providerTimeoutRate: 0.01
        providerRetryRate: 0.1
        tokenUsageSpike: 3
        monthlyCostRate: 1000
        cacheHitRate: 0.3
        providerAvailabilitySLO: 0.995
        providerLatencySLO: 10
      durations:
        providerErrorRate: "5m"
        providerDown: "5m"
        allProvidersDown: "2m"
        providerLatency: "10m"
        providerTimeout: "5m"
        circuitBreakerOpen: "1m"
        multipleCircuitBreakers: "2m"
        providerRetryRate: "10m"
        tokenUsageSpike: "5m"
        highCostRate: "15m"
        lowCacheHitRate: "30m"
        healthCheckFailing: "3m"
        sloViolation: "15m"
        latencySLO: "15m"
  serviceMonitor:
    enabled: false
    namespace: ""
    namespaceSelector: {}
    portName: http         # Must match a named port on the orchestrator Service.
    interval: 30s
    scrapeTimeout: 10s
    scheme: ""
    tlsConfig: {}
    relabelings: []
    metricRelabelings: []
    additionalLabels: {}
  grafana:
    enabled: false
    namespace: ""
    folder: OSS AI Agent Tool
    annotations: {}
    additionalLabels: {}

jaeger:
  enabled: true
  image: jaegertracing/all-in-one:1.57
  podSecurityContext:
    runAsNonRoot: true
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL
  resources: {}

langfuse:
  enabled: false
  replicas: 1
  image: langfuse/langfuse:2.14.1
  publicUrl: http://localhost:3000
  databaseUrl: ""
  nextAuthSecret: ""
  salt: ""
  telemetryEnabled: "false"
  resources: {}
  orchestrator:
    baseUrl: ""
    publicKey: ""
    publicKeySecretName: ""
    publicKeySecretKey: public-key
    secretKey: ""
    secretKeySecretName: ""
    secretKeySecretKey: secret-key

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: example.com
      paths:
        - path: /
          pathType: Prefix
          service: gateway
  tls: []

retention:
  secrets:
    retentionVersions: 5
    retentionDays: 30
    purge:
      enabled: false
      schedule: "0 3 * * *"
      dryRun: false
      auditEnabled: true
      metricsEnabled: true
  planState:
    retentionDays: 30
    backend: postgres
    purge:
      enabled: false
      schedule: "0 4 * * *"
      dryRun: false
      auditEnabled: true
      metricsEnabled: true
      batchSize: 1000
  artifacts:
    retentionDays: 90
    backend: file
    purge:
      enabled: false
      schedule: "0 5 * * *"
      dryRun: false
      auditEnabled: true
      metricsEnabled: true
      batchSize: 100

security:
  cmek:
    retentionVersions: 3
    rotation:
      enabled: false
      schedule: "0 0 1 * *"
      dryRun: false
      auditEnabled: true
      rotateAllTenants: false
      tenants: []